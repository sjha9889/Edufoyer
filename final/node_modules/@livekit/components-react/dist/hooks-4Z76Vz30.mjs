import * as c from "react";
import { useRef as N, useMemo as te, useCallback as A, useEffect as ne } from "react";
import { u as k, r as se, a as j, b as ae, c as w, d as ce, e as re, f as C, g as oe, h as ie, i as _, j as ue, k as de, m as le, G as fe, n as pe, o as me, p as F, q as be, t as Se, v as Y, w as X, x as Z, y as ge, l as P, z as he, A as ve, B as V, C as Me, D as ye, E as Te, F as ke, H as Pe, I as Ee, J as we, K as Ce, M as U, N as Ae, O as De, P as Oe, Q as Ie, S as Ne, T as Re, U as Le, V as _e, W as K, X as Fe, Y as Ve, Z as qe, _ as Ue, $ as ze, a0 as Be, a1 as xe, a2 as He, a3 as We, a4 as Je, a5 as Ge, a6 as $e, a7 as L, a8 as Qe, a9 as je, aa as Ye } from "./contexts-BGRNBsB8.mjs";
import { m as E } from "./room-BRK61eNB.mjs";
import { ConnectionState as D, LocalTrackPublication as Xe, facingModeFromLocalTrack as Ze, Room as Ke, Track as h, createAudioAnalyser as q, ParticipantKind as z, Mutex as et } from "livekit-client";
const tt = (e) => {
  const t = c.useRef(e);
  return c.useEffect(() => {
    t.current = e;
  }), t;
};
function nt(e, t) {
  const n = at(), s = tt(t);
  return c.useLayoutEffect(() => {
    let a = !1;
    const r = e.current;
    if (!r) return;
    function o(i, u) {
      a || s.current(i, u);
    }
    return n == null || n.subscribe(r, o), () => {
      a = !0, n == null || n.unsubscribe(r, o);
    };
  }, [e.current, n, s]), n == null ? void 0 : n.observer;
}
function st() {
  let e = !1, t = [];
  const n = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const s = new ResizeObserver((a, r) => {
    t = t.concat(a), e || window.requestAnimationFrame(() => {
      const o = /* @__PURE__ */ new Set();
      for (let i = 0; i < t.length; i++) {
        if (o.has(t[i].target)) continue;
        o.add(t[i].target);
        const u = n.get(t[i].target);
        u == null || u.forEach((l) => l(t[i], r));
      }
      t = [], e = !1;
    }), e = !0;
  });
  return {
    observer: s,
    subscribe(a, r) {
      s.observe(a);
      const o = n.get(a) ?? [];
      o.push(r), n.set(a, o);
    },
    unsubscribe(a, r) {
      const o = n.get(a) ?? [];
      if (o.length === 1) {
        s.unobserve(a), n.delete(a);
        return;
      }
      const i = o.indexOf(r);
      i !== -1 && o.splice(i, 1), n.set(a, o);
    }
  };
}
let R;
const at = () => R || (R = st()), ct = (e) => {
  const [t, n] = c.useState({ width: 0, height: 0 });
  c.useLayoutEffect(() => {
    if (e.current) {
      const { width: a, height: r } = e.current.getBoundingClientRect();
      n({ width: a, height: r });
    }
  }, [e.current]);
  const s = c.useCallback(
    (a) => n(a.contentRect),
    []
  );
  return nt(e, s), t;
};
function b(e, t, n = !0) {
  const [s, a] = c.useState(t);
  return c.useEffect(() => {
    if (n && a(t), typeof window > "u" || !e) return;
    const r = e.subscribe(a);
    return () => r.unsubscribe();
  }, [e, n]), s;
}
function Dt(e) {
  const t = (r) => typeof window < "u" ? window.matchMedia(r).matches : !1, [n, s] = c.useState(t(e));
  function a() {
    s(t(e));
  }
  return c.useEffect(() => {
    const r = window.matchMedia(e);
    return a(), r.addListener ? r.addListener(a) : r.addEventListener("change", a), () => {
      r.removeListener ? r.removeListener(a) : r.removeEventListener("change", a);
    };
  }, [e]), n;
}
function Ot(e) {
  const t = k(e), n = c.useCallback(async () => {
    await t.startAudio();
  }, [t]), s = c.useMemo(
    () => se(t),
    [t]
  ), { canPlayAudio: a } = b(s, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { canPlayAudio: a, startAudio: n };
}
function It(e) {
  const { state: t, dispatch: n } = j().pin;
  return { buttonProps: c.useMemo(() => {
    const { className: a } = ae();
    return E(e, {
      className: a,
      disabled: !(t != null && t.length),
      onClick: () => {
        n && n({ msg: "clear_pin" });
      }
    });
  }, [e, n, t]) };
}
function Nt(e = {}) {
  const t = w(e.participant), { className: n, connectionQualityObserver: s } = c.useMemo(
    () => ce(t),
    [t]
  ), a = b(s, t.connectionQuality);
  return { className: n, quality: a };
}
function O(e) {
  const t = k(e), n = c.useMemo(() => re(t), [t]);
  return b(n, t.state);
}
function Rt(e, t) {
  const n = typeof e == "function" ? e : t, s = typeof e == "string" ? e : void 0, a = C(), { send: r, messageObservable: o, isSendingObservable: i } = c.useMemo(
    () => oe(a, s, n),
    [a, s, n]
  ), u = b(o, void 0), l = b(i, !1);
  return {
    message: u,
    send: r,
    isSending: l
  };
}
function Lt(e) {
  const t = C(), n = O(t);
  return { buttonProps: c.useMemo(() => {
    const { className: a, disconnect: r } = ie(t);
    return E(e, {
      className: a,
      onClick: () => r(e.stopTracks ?? !0),
      disabled: n === D.Disconnected
    });
  }, [t, e, n]) };
}
function rt(e) {
  if (e.publication instanceof Xe) {
    const t = e.publication.track;
    if (t) {
      const { facingMode: n } = Ze(t);
      return n;
    }
  }
  return "undefined";
}
function _t({ trackRef: e, props: t }) {
  const n = _(e), s = ue(), { className: a } = c.useMemo(() => de(), []), r = c.useMemo(() => le(n, s == null ? void 0 : s.pin.state), [n, s == null ? void 0 : s.pin.state]);
  return { mergedProps: c.useMemo(
    () => E(t, {
      className: a,
      onClick: (i) => {
        var u, l, f, d, p;
        (u = t.onClick) == null || u.call(t, i), r ? (f = s == null ? void 0 : (l = s.pin).dispatch) == null || f.call(l, {
          msg: "clear_pin"
        }) : (p = s == null ? void 0 : (d = s.pin).dispatch) == null || p.call(d, {
          msg: "set_pin",
          trackReference: n
        });
      }
    }),
    [t, a, n, r, s == null ? void 0 : s.pin]
  ), inFocus: r };
}
function Ft(e, t, n = {}) {
  const s = n.gridLayouts ?? fe, { width: a, height: r } = ct(e), o = pe(s, t, a, r);
  return c.useEffect(() => {
    e.current && o && (e.current.style.setProperty("--lk-col-count", o == null ? void 0 : o.columns.toString()), e.current.style.setProperty("--lk-row-count", o == null ? void 0 : o.rows.toString()));
  }, [e, o]), {
    layout: o,
    containerWidth: a,
    containerHeight: r
  };
}
function B(e, t = {}) {
  var i, u;
  const n = typeof e == "string" ? t.participant : e.participant, s = w(n), a = typeof e == "string" ? { participant: s, source: e } : e, [r, o] = c.useState(
    !!((i = a.publication) != null && i.isMuted || (u = s.getTrackPublication(a.source)) != null && u.isMuted)
  );
  return c.useEffect(() => {
    const l = me(a).subscribe(o);
    return () => l.unsubscribe();
  }, [F(a)]), r;
}
function ot(e) {
  const t = w(e), n = c.useMemo(() => be(t), [t]);
  return b(n, t.isSpeaking);
}
function it(e = {}) {
  const t = k(e.room), [n, s] = c.useState(t.localParticipant), [a, r] = c.useState(
    n.isMicrophoneEnabled
  ), [o, i] = c.useState(n.isCameraEnabled), [u, l] = c.useState(
    n.isScreenShareEnabled
  ), [f, d] = c.useState(
    n.lastMicrophoneError
  ), [p, m] = c.useState(n.lastCameraError), [g, S] = c.useState(
    void 0
  ), [y, v] = c.useState(void 0), T = (M) => {
    i(M.isCameraEnabled), r(M.isMicrophoneEnabled), l(M.isScreenShareEnabled), v(M.cameraTrack), S(M.microphoneTrack), d(M.participant.lastMicrophoneError), m(M.participant.lastCameraError), s(M.participant);
  };
  return c.useEffect(() => {
    const M = Se(t.localParticipant).subscribe(T);
    return () => M.unsubscribe();
  }, [t]), {
    isMicrophoneEnabled: a,
    isScreenShareEnabled: u,
    isCameraEnabled: o,
    microphoneTrack: g,
    cameraTrack: y,
    lastMicrophoneError: f,
    lastCameraError: p,
    localParticipant: n
  };
}
function Vt() {
  const e = C(), t = c.useMemo(
    () => Y(e.localParticipant),
    [e]
  );
  return b(t, e.localParticipant.permissions);
}
function qt({
  kind: e,
  room: t,
  track: n,
  requestPermissions: s,
  onError: a
}) {
  const r = X(), o = c.useMemo(() => t ?? r ?? new Ke(), [t, r]), i = c.useMemo(
    () => Z(e, a, s),
    [e, s, a]
  ), u = b(i, []), [l, f] = c.useState(
    (o == null ? void 0 : o.getActiveDevice(e)) ?? "default"
  ), { className: d, activeDeviceObservable: p, setActiveMediaDevice: m } = c.useMemo(
    () => ge(e, o),
    [e, o, n]
  );
  return c.useEffect(() => {
    const g = p.subscribe((S) => {
      S && (P.info("setCurrentDeviceId", S), f(S));
    });
    return () => {
      g == null || g.unsubscribe();
    };
  }, [p]), { devices: u, className: d, activeDeviceId: l, setActiveMediaDevice: m };
}
function Ut({
  kind: e,
  onError: t
}) {
  const n = c.useMemo(
    () => Z(e, t),
    [e, t]
  );
  return b(n, []);
}
function ut(e, t, n = {}) {
  const s = c.useRef([]), a = c.useRef(-1), r = t !== a.current, o = typeof n.customSortFunction == "function" ? n.customSortFunction(e) : he(e);
  let i = [...o];
  if (r === !1)
    try {
      i = ve(s.current, o, t);
    } catch (u) {
      P.error("Error while running updatePages(): ", u);
    }
  return r ? s.current = o : s.current = i, a.current = t, i;
}
function zt(e, t) {
  const [n, s] = c.useState(1), a = Math.max(Math.ceil(t.length / e), 1);
  n > a && s(a);
  const r = n * e, o = r - e, i = (d) => {
    s((p) => d === "next" ? p === a ? p : p + 1 : p === 1 ? p : p - 1);
  }, u = (d) => {
    d > a ? s(a) : d < 1 ? s(1) : s(d);
  }, f = ut(t, e).slice(o, r);
  return {
    totalPageCount: a,
    nextPage: () => i("next"),
    prevPage: () => i("previous"),
    setPage: u,
    firstItemIndex: o,
    lastItemIndex: r,
    tracks: f,
    currentPage: n
  };
}
function Bt(e = {}) {
  let t = V();
  e.participant && (t = e.participant);
  const n = c.useMemo(() => Me(t), [t]), { identity: s, name: a, metadata: r } = b(n, {
    name: t == null ? void 0 : t.name,
    identity: t == null ? void 0 : t.identity,
    metadata: t == null ? void 0 : t.metadata
  });
  return { identity: s, name: a, metadata: r };
}
function xt(e = {}) {
  const t = w(e.participant), n = c.useMemo(() => Y(t), [t]);
  return b(n, t.permissions);
}
function Ht({
  trackRef: e,
  onParticipantClick: t,
  disableSpeakingIndicator: n,
  htmlProps: s
}) {
  const a = _(e), r = c.useMemo(() => {
    const { className: p } = ye();
    return E(s, {
      className: p,
      onClick: (m) => {
        var g;
        if ((g = s.onClick) == null || g.call(s, m), typeof t == "function") {
          const S = a.publication ?? a.participant.getTrackPublication(a.source);
          t({ participant: a.participant, track: S });
        }
      }
    });
  }, [
    s,
    t,
    a.publication,
    a.source,
    a.participant
  ]), o = a.participant.getTrackPublication(h.Source.Microphone), i = c.useMemo(() => ({
    participant: a.participant,
    source: h.Source.Microphone,
    publication: o
  }), [o, a.participant]), u = B(a), l = B(i), f = ot(a.participant), d = rt(a);
  return {
    elementProps: {
      "data-lk-audio-muted": l,
      "data-lk-video-muted": u,
      "data-lk-speaking": n === !0 ? !1 : f,
      "data-lk-local-participant": a.participant.isLocal,
      "data-lk-source": a.source,
      "data-lk-facing-mode": d,
      ...r
    }
  };
}
function ee(e = {}) {
  const t = k(e.room), [n, s] = c.useState([]);
  return c.useEffect(() => {
    const a = Te(t, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(s);
    return () => a.unsubscribe();
  }, [t, JSON.stringify(e.updateOnlyOn)]), n;
}
function dt(e = {}) {
  const t = ee(e), { localParticipant: n } = it(e);
  return c.useMemo(
    () => [n, ...t],
    [n, t]
  );
}
function Wt(e) {
  return e = ke(e), c.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function Jt(e, t = {}) {
  const n = C(), [s] = c.useState(t.updateOnlyOn), a = c.useMemo(() => typeof e == "string" ? Pe(n, e, {
    additionalEvents: s
  }) : Ee(n, e, {
    additionalEvents: s
  }), [n, JSON.stringify(e), s]), [r, o] = c.useState({
    p: void 0
  });
  return c.useEffect(() => {
    const i = a.subscribe((u) => o({ p: u }));
    return () => i.unsubscribe();
  }, [a]), r.p;
}
function Gt(e = {}) {
  const t = k(e.room), n = c.useMemo(() => we(t), [t]), { name: s, metadata: a } = b(n, {
    name: t.name,
    metadata: t.metadata
  });
  return { name: s, metadata: a };
}
function lt() {
  const e = C(), t = c.useMemo(() => Ce(e), [e]);
  return b(t, e.activeSpeakers);
}
function $t(e) {
  const [t, n] = c.useState(
    U(e)
  ), s = lt();
  return c.useEffect(() => {
    n(U(e));
  }, [s, e]), t;
}
function Qt({ room: e, props: t }) {
  const n = k(e), { className: s, roomAudioPlaybackAllowedObservable: a, handleStartAudioPlayback: r } = c.useMemo(
    () => Ae(),
    []
  ), o = c.useMemo(
    () => a(n),
    [n, a]
  ), { canPlayAudio: i } = b(o, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { mergedProps: c.useMemo(
    () => E(t, {
      className: s,
      onClick: () => {
        r(n);
      },
      style: { display: i ? "none" : "block" }
    }),
    [t, s, i, r, n]
  ), canPlayAudio: i };
}
function jt({ room: e, props: t }) {
  const n = k(e), { className: s, roomVideoPlaybackAllowedObservable: a, handleStartVideoPlayback: r } = c.useMemo(
    () => De(),
    []
  ), o = c.useMemo(
    () => a(n),
    [n, a]
  ), { canPlayVideo: i } = b(o, {
    canPlayVideo: n.canPlaybackVideo
  });
  return { mergedProps: c.useMemo(
    () => E(t, {
      className: s,
      onClick: () => {
        r(n);
      },
      style: { display: i ? "none" : "block" }
    }),
    [t, s, i, r, n]
  ), canPlayVideo: i };
}
function Yt(e, t = {}) {
  const n = c.useRef(null), s = c.useRef(null), a = t.minSwipeDistance ?? 50, r = (u) => {
    s.current = null, n.current = u.targetTouches[0].clientX;
  }, o = (u) => {
    s.current = u.targetTouches[0].clientX;
  }, i = c.useCallback(() => {
    if (!n.current || !s.current)
      return;
    const u = n.current - s.current, l = u > a, f = u < -a;
    l && t.onLeftSwipe && t.onLeftSwipe(), f && t.onRightSwipe && t.onRightSwipe();
  }, [a, t]);
  c.useEffect(() => {
    const u = e.current;
    return u && (u.addEventListener("touchstart", r, { passive: !0 }), u.addEventListener("touchmove", o, { passive: !0 }), u.addEventListener("touchend", i, { passive: !0 })), () => {
      u && (u.removeEventListener("touchstart", r), u.removeEventListener("touchmove", o), u.removeEventListener("touchend", i));
    };
  }, [e, i]);
}
function Xt({ props: e }) {
  const { dispatch: t, state: n } = j().widget, { className: s } = c.useMemo(() => Oe(), []);
  return { mergedProps: c.useMemo(() => E(e, {
    className: s,
    onClick: () => {
      t && t({ msg: "toggle_chat" });
    },
    "aria-pressed": n != null && n.showChat ? "true" : "false",
    "data-lk-unread-msgs": n ? n.unreadMessages < 10 ? n.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, s, t, n]) };
}
function Zt(e, t, n = {}) {
  const [s, a] = c.useState(void 0);
  return c.useEffect(() => {
    var o;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((o = n.userInfo) == null ? void 0 : o.identity) === void 0)
      return;
    (async () => {
      P.debug("fetching token");
      const i = new URLSearchParams({ ...n.userInfo, roomName: t }), u = await fetch(`${e}?${i.toString()}`);
      if (!u.ok) {
        P.error(
          `Could not fetch token. Server responded with status ${u.status}: ${u.statusText}`
        );
        return;
      }
      const { accessToken: l } = await u.json();
      a(l);
    })();
  }, [e, t, JSON.stringify(n)]), s;
}
function Kt(e) {
  var r, o;
  const t = _(e), { className: n, mediaMutedObserver: s } = c.useMemo(
    () => Ie(t),
    [F(t)]
  );
  return { isMuted: b(
    s,
    !!((r = t.publication) != null && r.isMuted || (o = t.participant.getTrackPublication(t.source)) != null && o.isMuted)
  ), className: n };
}
function en({
  source: e,
  onChange: t,
  initialState: n,
  captureOptions: s,
  publishOptions: a,
  onDeviceError: r,
  ...o
}) {
  var T;
  const i = X(), u = (T = i == null ? void 0 : i.localParticipant) == null ? void 0 : T.getTrackPublication(e), l = c.useRef(!1), { toggle: f, className: d, pendingObserver: p, enabledObserver: m } = c.useMemo(
    () => i ? Ne(e, i, s, a, r) : Re(),
    [i, e, JSON.stringify(s), a]
  ), g = b(p, !1), S = b(m, n ?? !!(u != null && u.isEnabled));
  c.useEffect(() => {
    t == null || t(S, l.current), l.current = !1;
  }, [S, t]), c.useEffect(() => {
    n !== void 0 && (P.debug("forcing initial toggle state", e, n), f(n));
  }, []);
  const y = c.useMemo(() => E(o, { className: d }), [o, d]), v = c.useCallback(
    (M) => {
      var I;
      l.current = !0, f().catch(() => l.current = !1), (I = o.onClick) == null || I.call(o, M);
    },
    [o, f]
  );
  return {
    toggle: f,
    enabled: S,
    pending: g,
    track: u,
    buttonProps: {
      ...y,
      "aria-pressed": S,
      "data-lk-source": e,
      "data-lk-enabled": S,
      disabled: g,
      onClick: v
    }
  };
}
function tn(e = [
  h.Source.Camera,
  h.Source.Microphone,
  h.Source.ScreenShare,
  h.Source.ScreenShareAudio,
  h.Source.Unknown
], t = {}) {
  const n = k(t.room), [s, a] = c.useState([]), [r, o] = c.useState([]), i = c.useMemo(() => e.map((l) => Le(l) ? l.source : l), [JSON.stringify(e)]);
  return c.useEffect(() => {
    const l = _e(n, i, {
      additionalRoomEvents: t.updateOnlyOn,
      onlySubscribed: t.onlySubscribed
    }).subscribe(({ trackReferences: f, participants: d }) => {
      P.debug("setting track bundles", f, d), a(f), o(d);
    });
    return () => l.unsubscribe();
  }, [
    n,
    JSON.stringify(t.onlySubscribed),
    JSON.stringify(t.updateOnlyOn),
    JSON.stringify(e)
  ]), c.useMemo(() => {
    if (K(e)) {
      const l = pt(e, r), f = Array.from(s);
      return r.forEach((d) => {
        l.has(d.identity) && (l.get(d.identity) ?? []).forEach((m) => {
          if (s.find(
            ({ participant: S, publication: y }) => d.identity === S.identity && y.source === m
          ))
            return;
          P.debug(
            `Add ${m} placeholder for participant ${d.identity}.`
          );
          const g = {
            participant: d,
            source: m
          };
          f.push(g);
        });
      }), f;
    } else
      return s;
  }, [s, r, e]);
}
function ft(e, t) {
  const n = new Set(e);
  for (const s of t)
    n.delete(s);
  return n;
}
function pt(e, t) {
  const n = /* @__PURE__ */ new Map();
  if (K(e)) {
    const s = e.filter((a) => a.withPlaceholder).map((a) => a.source);
    t.forEach((a) => {
      const r = a.getTrackPublications().map((i) => {
        var u;
        return (u = i.track) == null ? void 0 : u.source;
      }).filter((i) => i !== void 0), o = Array.from(
        ft(new Set(s), new Set(r))
      );
      o.length > 0 && n.set(a.identity, o);
    });
  }
  return n;
}
function mt(e) {
  const [t, n] = c.useState(Fe(e)), { trackObserver: s } = c.useMemo(() => Ve(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return c.useEffect(() => {
    const a = s.subscribe((r) => {
      n(r);
    });
    return () => a == null ? void 0 : a.unsubscribe();
  }, [s]), {
    participant: e.participant,
    source: e.source ?? h.Source.Unknown,
    publication: t
  };
}
function nn(e, t) {
  const n = w(t);
  return mt({ name: e, participant: n });
}
function sn(e) {
  const t = C(), n = O(t), s = c.useMemo(
    () => n === D.Disconnected,
    [n]
  ), a = c.useMemo(
    () => qe(t, e),
    [t, e, s]
  ), r = b(a.isSendingObservable, !1), o = b(a.messageObservable, []);
  return { send: a.send, chatMessages: o, isSending: r };
}
function an(e = {}) {
  const [t, n] = c.useState(
    Ue(e.defaults, e.preventLoad ?? !1)
  ), s = c.useCallback((u) => {
    n((l) => ({ ...l, audioEnabled: u }));
  }, []), a = c.useCallback((u) => {
    n((l) => ({ ...l, videoEnabled: u }));
  }, []), r = c.useCallback((u) => {
    n((l) => ({ ...l, audioDeviceId: u }));
  }, []), o = c.useCallback((u) => {
    n((l) => ({ ...l, videoDeviceId: u }));
  }, []), i = c.useCallback((u) => {
    n((l) => ({ ...l, username: u }));
  }, []);
  return c.useEffect(() => {
    ze(t, e.preventSave ?? !1);
  }, [t, e.preventSave]), {
    userChoices: t,
    saveAudioInputEnabled: s,
    saveVideoInputEnabled: a,
    saveAudioInputDeviceId: r,
    saveVideoInputDeviceId: o,
    saveUsername: i
  };
}
function cn(e, t = {}) {
  const n = w(e), s = k(t.room), a = c.useMemo(() => Be(s, n), [s, n]);
  return b(
    a,
    n.isLocal ? n.isE2EEEnabled : !!(n != null && n.isEncrypted)
  );
}
function rn(e, t = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const n = xe(e) ? e.publication.track : e, [s, a] = c.useState(0);
  return c.useEffect(() => {
    if (!n || !n.mediaStream)
      return;
    const { cleanup: r, analyser: o } = q(n, t), i = o.frequencyBinCount, u = new Uint8Array(i), f = setInterval(() => {
      o.getByteFrequencyData(u);
      let d = 0;
      for (let p = 0; p < u.length; p++) {
        const m = u[p];
        d += m * m;
      }
      a(Math.sqrt(d / u.length) / 255);
    }, 1e3 / 30);
    return () => {
      r(), clearInterval(f);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), s;
}
const bt = (e) => {
  const t = (n) => {
    let r = 1 - Math.max(-100, Math.min(-10, n)) * -1 / 100;
    return r = Math.sqrt(r), r;
  };
  return e.map((n) => n === -1 / 0 ? 0 : t(n));
}, St = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function on(e, t = {}) {
  var o;
  const n = e instanceof h ? e : (o = e == null ? void 0 : e.publication) == null ? void 0 : o.track, s = { ...St, ...t }, [a, r] = c.useState(
    new Array(s.bands).fill(0)
  );
  return c.useEffect(() => {
    if (!n || !(n != null && n.mediaStream))
      return;
    const { analyser: i, cleanup: u } = q(n, s.analyserOptions), l = i.frequencyBinCount, f = new Float32Array(l), p = setInterval(() => {
      i.getFloatFrequencyData(f);
      let m = new Float32Array(f.length);
      for (let v = 0; v < f.length; v++)
        m[v] = f[v];
      m = m.slice(t.loPass, t.hiPass);
      const g = bt(m), S = Math.ceil(g.length / s.bands), y = [];
      for (let v = 0; v < s.bands; v++) {
        const T = g.slice(v * S, (v + 1) * S).reduce((M, I) => M += I, 0);
        y.push(T / S);
      }
      r(y);
    }, s.updateInterval);
    return () => {
      u(), clearInterval(p);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), a;
}
const gt = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function un(e, t = {}) {
  var f;
  const n = e instanceof h ? e : (f = e == null ? void 0 : e.publication) == null ? void 0 : f.track, s = { ...gt, ...t }, a = c.useRef(new Float32Array()), r = c.useRef(performance.now()), o = c.useRef(0), [i, u] = c.useState([]), l = c.useCallback((d) => {
    u(
      Array.from(
        vt(d, s.barCount).map((p) => Math.sqrt(p) * s.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return c.useEffect(() => {
    if (!n || !(n != null && n.mediaStream))
      return;
    const { analyser: d, cleanup: p } = q(n, {
      fftSize: x(s.barCount)
    }), m = x(s.barCount), g = new Float32Array(m), S = () => {
      if (y = requestAnimationFrame(S), d.getFloatTimeDomainData(g), a.current.map((v, T) => v + g[T]), o.current += 1, performance.now() - r.current >= s.updateInterval) {
        const v = g.map((T) => T / o.current);
        l(v), r.current = performance.now(), o.current = 0;
      }
    };
    let y = requestAnimationFrame(S);
    return () => {
      p(), cancelAnimationFrame(y);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t), l]), {
    bars: i
  };
}
function x(e) {
  return e < 32 ? 32 : ht(e);
}
function ht(e) {
  let t = 2;
  for (; e >>= 1; )
    t <<= 1;
  return t;
}
function vt(e, t) {
  const n = Math.floor(e.length / t), s = new Float32Array(t);
  for (let a = 0; a < t; a++) {
    const r = n * a;
    let o = 0;
    for (let i = 0; i < n; i++)
      o = o + Math.abs(e[r + i]);
    s[a] = o / n;
  }
  return s;
}
function H(e, t) {
  const n = V(), s = dt({ updateOnlyOn: [] }), a = c.useMemo(() => t ? s.find((i) => i.identity === t) : n, [t, s, n]), r = c.useMemo(() => {
    if (a)
      return He(a, { sources: e });
  }, [a, JSON.stringify(e)]);
  return b(r, []);
}
function Mt(e) {
  var n, s, a;
  const t = c.useMemo(
    () => {
      var r;
      return (r = e == null ? void 0 : e.publication) != null && r.track ? We(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(n = e == null ? void 0 : e.publication) == null ? void 0 : n.track]
  );
  return b(t, {
    timestamp: Date.now(),
    rtpTimestamp: (a = (s = e == null ? void 0 : e.publication) == null ? void 0 : s.track) == null ? void 0 : a.rtpTimestamp
  });
}
const yt = {
  bufferSize: 100
  // maxAge: 2_000,
};
function Tt(e, t) {
  const n = { ...yt, ...t }, [s, a] = c.useState([]), r = Mt(e), o = (i) => {
    var u;
    (u = n.onTranscription) == null || u.call(n, i), a(
      (l) => Ge(
        l,
        // when first receiving a segment, add the current media timestamp to it
        i.map((f) => $e(f, r)),
        n.bufferSize
      )
    );
  };
  return c.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const i = Je(e.publication).subscribe((u) => {
      o(...u);
    });
    return () => {
      i.unsubscribe();
    };
  }, [e && F(e), o]), { segments: s };
}
function kt(e = {}) {
  const t = V(), n = e.participant ?? t, s = c.useMemo(
    // weird typescript constraint
    () => n ? L(n) : L(n),
    [n]
  );
  return b(s, {
    attributes: n == null ? void 0 : n.attributes
  });
}
function dn(e, t = {}) {
  const n = w(t.participant), [s, a] = c.useState(n.attributes[e]);
  return c.useEffect(() => {
    if (!n)
      return;
    const r = L(n).subscribe((o) => {
      o.changed[e] !== void 0 && a(o.attributes[e]);
    });
    return () => {
      r.unsubscribe();
    };
  }, [n, e]), s;
}
const W = "lk.agent.state";
function ln() {
  const e = ee(), t = e.find(
    (d) => d.kind === z.AGENT && !("lk.publish_on_behalf" in d.attributes)
  ), n = e.find(
    (d) => d.kind === z.AGENT && d.attributes["lk.publish_on_behalf"] === (t == null ? void 0 : t.identity)
  ), s = H(
    [h.Source.Microphone, h.Source.Camera],
    t == null ? void 0 : t.identity
  ), a = H(
    [h.Source.Microphone, h.Source.Camera],
    n == null ? void 0 : n.identity
  ), r = s.find((d) => d.source === h.Source.Microphone) ?? a.find((d) => d.source === h.Source.Microphone), o = s.find((d) => d.source === h.Source.Camera) ?? a.find((d) => d.source === h.Source.Camera), { segments: i } = Tt(r), u = O(), { attributes: l } = kt({ participant: t }), f = c.useMemo(() => u === D.Disconnected ? "disconnected" : u === D.Connecting || !t || !(l != null && l[W]) ? "connecting" : l[W], [l, t, u]);
  return {
    agent: t,
    state: f,
    audioTrack: r,
    videoTrack: o,
    agentTranscriptions: i,
    agentAttributes: l
  };
}
function fn(e) {
  const t = k(e), n = O(t), s = c.useMemo(() => Qe(t), [t, n]);
  return b(s, t.isRecording);
}
function Pt(e) {
  const t = C(), s = O(t) === D.Disconnected, a = c.useMemo(() => je(t, e), [t, e]);
  return { textStreams: b(s ? void 0 : a, []) };
}
function pn(e) {
  const { participantIdentities: t, trackSids: n } = e ?? {}, { textStreams: s } = Pt(Ye.TRANSCRIPTION);
  return c.useMemo(
    () => s.filter(
      (r) => t ? t.includes(r.participantInfo.identity) : !0
    ).filter(
      (r) => {
        var o;
        return n ? n.includes(((o = r.streamInfo.attributes) == null ? void 0 : o["lk.transcribed_track_id"]) ?? "") : !0;
      }
    ),
    [s, t, n]
  );
}
const J = 2, G = 400, $ = 3, Q = 1e3;
function mn(e) {
  const t = N([]), n = te(() => new et(), []), s = A(async () => n.lock().then(async (f) => {
    for (; ; ) {
      const d = t.current.pop();
      if (!d) {
        f();
        break;
      }
      switch (d.type) {
        case "connect":
          await d.room.connect(...d.args).then(d.resolve).catch(d.reject);
          break;
        case "disconnect":
          await d.room.disconnect(...d.args).then(d.resolve).catch(d.reject);
          break;
      }
    }
  }), []), a = N([]), r = A((f) => {
    let d = 0;
    a.current = a.current.filter((p) => {
      const m = f.getTime() - p.getTime() < Q;
      return m && (d += 1), m;
    }), d > $ && P.warn(
      `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${$}x in ${Q}ms). This is not recommended.`
    );
  }, []);
  ne(() => {
    t.current = [];
    const f = /* @__PURE__ */ new Date();
    a.current.push(f), r(f);
  }, [e, r]);
  const o = N([]), i = A((f) => {
    let d = 0;
    o.current = o.current.filter((p) => {
      const m = f.getTime() - p.getTime() < G;
      return m && (d += 1), m;
    }), d > J && P.warn(
      `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${J}x in ${G}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`
    );
  }, []), u = A(
    async (...f) => new Promise((d, p) => {
      if (!e)
        throw new Error("Called connect(), but room was unset");
      const m = /* @__PURE__ */ new Date();
      i(m), t.current.push({ type: "connect", room: e, args: f, resolve: d, reject: p }), o.current.push(m), s();
    }),
    [e, i, s]
  ), l = A(
    async (...f) => new Promise((d, p) => {
      if (!e)
        throw new Error("Called discconnect(), but room was unset");
      const m = /* @__PURE__ */ new Date();
      i(m), t.current.push({ type: "disconnect", room: e, args: f, resolve: d, reject: p }), o.current.push(m), s();
    }),
    [e, i, s]
  );
  return {
    connect: e ? u : null,
    disconnect: e ? l : null
  };
}
export {
  mn as $,
  Vt as A,
  Wt as B,
  it as C,
  Ot as D,
  Rt as E,
  rt as F,
  B as G,
  ot as H,
  Bt as I,
  xt as J,
  dt as K,
  Jt as L,
  ee as M,
  $t as N,
  lt as O,
  Zt as P,
  nn as Q,
  rn as R,
  un as S,
  H as T,
  Tt as U,
  ln as V,
  kt as W,
  dn as X,
  fn as Y,
  Pt as Z,
  pn as _,
  O as a,
  Xt as b,
  Lt as c,
  _t as d,
  qt as e,
  Qt as f,
  jt as g,
  en as h,
  Nt as i,
  b as j,
  Kt as k,
  Ht as l,
  cn as m,
  Ft as n,
  zt as o,
  Yt as p,
  ct as q,
  ut as r,
  on as s,
  tn as t,
  It as u,
  Gt as v,
  sn as w,
  an as x,
  Ut as y,
  Dt as z
};
//# sourceMappingURL=hooks-4Z76Vz30.mjs.map
