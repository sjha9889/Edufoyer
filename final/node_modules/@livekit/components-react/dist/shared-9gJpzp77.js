"use strict";const T=require("react"),o=require("./shared-jZUXaCo3.js"),d=require("./shared-BCAxwLPA.js"),l=require("livekit-client");function F(e){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const n in e)if(n!=="default"){const s=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,s.get?s:{enumerable:!0,get:()=>e[n]})}}return t.default=e,Object.freeze(t)}const c=F(T);function z(e){const t=o.useEnsureRoom(e),n=c.useCallback(async()=>{await t.startAudio()},[t]),s=c.useMemo(()=>o.roomAudioPlaybackAllowedObservable(t),[t]),{canPlayAudio:r}=d.useObservableState(s,{canPlayAudio:t.canPlaybackAudio});return{canPlayAudio:r,startAudio:n}}function K(e){const{state:t,dispatch:n}=d.useLayoutContext().pin;return{buttonProps:c.useMemo(()=>{const{className:r}=o.setupClearPinButton();return d.mergeProps(e,{className:r,disabled:!(t!=null&&t.length),onClick:()=>{n&&n({msg:"clear_pin"})}})},[e,n,t])}}function Q(e,t){const n=typeof e=="function"?e:t,s=typeof e=="string"?e:void 0,r=o.useRoomContext(),{send:a,messageObservable:u,isSendingObservable:p}=c.useMemo(()=>o.setupDataMessageHandler(r,s,n),[r,s,n]),m=d.useObservableState(u,void 0),f=d.useObservableState(p,!1);return{message:m,send:a,isSending:f}}const V={connect:!0,audio:!1,video:!1};function Y(e){const{token:t,serverUrl:n,options:s,room:r,connectOptions:a,connect:u,audio:p,video:m,screen:f,onConnected:b,onDisconnected:i,onError:S,onMediaDeviceFailure:v,onEncryptionError:P,simulateParticipants:R,...M}={...V,...e};s&&r&&o.log.warn("when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.");const[g,$]=c.useState(),C=c.useRef(u);c.useEffect(()=>{$(r??new l.Room(s))},[r,JSON.stringify(s,d.roomOptionsStringifyReplacer)]);const J=c.useMemo(()=>{const{className:h}=o.setupLiveKitRoom();return d.mergeProps(M,{className:h})},[M]);return c.useEffect(()=>{if(!g)return;const h=()=>{const k=g.localParticipant;o.log.debug("trying to publish local tracks"),Promise.all([k.setMicrophoneEnabled(!!p,typeof p!="boolean"?p:void 0),k.setCameraEnabled(!!m,typeof m!="boolean"?m:void 0),k.setScreenShareEnabled(!!f,typeof f!="boolean"?f:void 0)]).catch(O=>{o.log.warn(O),S==null||S(O)})},w=(k,O)=>{const U=l.MediaDeviceFailure.getFailure(k);v==null||v(U,O)},D=k=>{P==null||P(k)},N=k=>{i==null||i(k)},A=()=>{b==null||b()};return g.on(l.RoomEvent.SignalConnected,h).on(l.RoomEvent.MediaDevicesError,w).on(l.RoomEvent.EncryptionError,D).on(l.RoomEvent.Disconnected,N).on(l.RoomEvent.Connected,A),()=>{g.off(l.RoomEvent.SignalConnected,h).off(l.RoomEvent.MediaDevicesError,w).off(l.RoomEvent.EncryptionError,D).off(l.RoomEvent.Disconnected,N).off(l.RoomEvent.Connected,A)}},[g,p,m,f,S,P,v,b,i]),c.useEffect(()=>{if(g){if(R){g.simulateParticipants({participants:{count:R},publish:{audio:!0,useRealTracks:!0}});return}if(u){if(C.current=!0,o.log.debug("connecting"),!t){o.log.debug("no token yet");return}if(!n){o.log.warn("no livekit url provided"),S==null||S(Error("no livekit url provided"));return}g.connect(n,t,a).catch(h=>{o.log.warn(h),C.current===!0&&(S==null||S(h))})}else o.log.debug("disconnecting because connect is false"),C.current=!1,g.disconnect()}},[u,t,JSON.stringify(a),g,S,n,R]),c.useEffect(()=>{if(g)return()=>{o.log.info("disconnecting on onmount"),g.disconnect()}},[g]),{room:g,htmlProps:J}}function X(e={}){let t=d.useMaybeParticipantContext();e.participant&&(t=e.participant);const n=c.useMemo(()=>o.participantInfoObserver(t),[t]),{identity:s,name:r,metadata:a}=d.useObservableState(n,{name:t==null?void 0:t.name,identity:t==null?void 0:t.identity,metadata:t==null?void 0:t.metadata});return{identity:s,name:r,metadata:a}}function Z(e={}){const t=d.useEnsureParticipant(e.participant),n=c.useMemo(()=>o.participantPermissionObserver(t),[t]);return d.useObservableState(n,t.permissions)}function E(e={}){const t=o.useEnsureRoom(e.room),[n,s]=c.useState([]);return c.useEffect(()=>{const r=o.connectedParticipantsObserver(t,{additionalRoomEvents:e.updateOnlyOn}).subscribe(s);return()=>r.unsubscribe()},[t,JSON.stringify(e.updateOnlyOn)]),n}function q(e={}){const t=E(e),{localParticipant:n}=o.useLocalParticipant(e);return c.useMemo(()=>[n,...t],[n,t])}function ee(e,t={}){const n=o.useRoomContext(),[s]=c.useState(t.updateOnlyOn),r=c.useMemo(()=>typeof e=="string"?o.connectedParticipantObserver(n,e,{additionalEvents:s}):o.participantByIdentifierObserver(n,e,{additionalEvents:s}),[n,JSON.stringify(e),s]),[a,u]=c.useState({p:void 0});return c.useEffect(()=>{const p=r.subscribe(m=>u({p:m}));return()=>p.unsubscribe()},[r]),a.p}function te(e={}){const t=o.useEnsureRoom(e.room),n=c.useMemo(()=>o.roomInfoObserver(t),[t]),{name:s,metadata:r}=d.useObservableState(n,{name:t.name,metadata:t.metadata});return{name:s,metadata:r}}function j(){const e=o.useRoomContext(),t=c.useMemo(()=>o.activeSpeakerObserver(e),[e]);return d.useObservableState(t,e.activeSpeakers)}function ne(e){const[t,n]=c.useState(o.sortParticipants(e)),s=j();return c.useEffect(()=>{n(o.sortParticipants(e))},[s,e]),t}function se(e,t,n={}){const[s,r]=c.useState(void 0);return c.useEffect(()=>{var u;if(e===void 0)throw Error("token endpoint needs to be defined");if(((u=n.userInfo)==null?void 0:u.identity)===void 0)return;(async()=>{o.log.debug("fetching token");const p=new URLSearchParams({...n.userInfo,roomName:t}),m=await fetch(`${e}?${p.toString()}`);if(!m.ok){o.log.error(`Could not fetch token. Server responded with status ${m.status}: ${m.statusText}`);return}const{accessToken:f}=await m.json();r(f)})()},[e,t,JSON.stringify(n)]),s}function oe(e){const[t,n]=c.useState(o.getTrackByIdentifier(e)),{trackObserver:s}=c.useMemo(()=>o.setupMediaTrack(e),[e.participant.sid??e.participant.identity,e.source]);return c.useEffect(()=>{const r=s.subscribe(a=>{n(a)});return()=>r==null?void 0:r.unsubscribe()},[s]),{participant:e.participant,source:e.source??l.Track.Source.Unknown,publication:t}}function re(e,t){const n=d.useEnsureParticipant(t);return oe({name:e,participant:n})}function y(e,t){const n=d.useMaybeParticipantContext(),s=q({updateOnlyOn:[]}),r=c.useMemo(()=>t?s.find(p=>p.identity===t):n,[t,s,n]),a=c.useMemo(()=>{if(r)return o.participantTracksObservable(r,{sources:e})},[r,JSON.stringify(e)]);return d.useObservableState(a,[])}function ce(e){var n,s,r;const t=c.useMemo(()=>{var a;return(a=e==null?void 0:e.publication)!=null&&a.track?o.trackSyncTimeObserver(e==null?void 0:e.publication.track):void 0},[(n=e==null?void 0:e.publication)==null?void 0:n.track]);return d.useObservableState(t,{timestamp:Date.now(),rtpTimestamp:(r=(s=e==null?void 0:e.publication)==null?void 0:s.track)==null?void 0:r.rtpTimestamp})}const ie={bufferSize:100};function B(e,t){const n={...ie,...t},[s,r]=c.useState([]),a=ce(e),u=p=>{var m;(m=n.onTranscription)==null||m.call(n,p),r(f=>o.dedupeSegments(f,p.map(b=>o.addMediaTimestampToTranscription(b,a)),n.bufferSize))};return c.useEffect(()=>{if(!(e!=null&&e.publication))return;const p=o.trackTranscriptionObserver(e.publication).subscribe(m=>{u(...m)});return()=>{p.unsubscribe()}},[e&&o.getTrackReferenceId(e),u]),{segments:s}}function G(e={}){const t=d.useMaybeParticipantContext(),n=e.participant??t,s=c.useMemo(()=>o.participantAttributesObserver(n),[n]);return d.useObservableState(s,{attributes:n==null?void 0:n.attributes})}function ae(e,t={}){const n=d.useEnsureParticipant(t.participant),[s,r]=c.useState(n.attributes[e]);return c.useEffect(()=>{if(!n)return;const a=o.participantAttributesObserver(n).subscribe(u=>{u.changed[e]!==void 0&&r(u.attributes[e])});return()=>{a.unsubscribe()}},[n,e]),s}const _="lk.agent.state";function ue(){const e=E(),t=e.find(i=>i.kind===l.ParticipantKind.AGENT&&!("lk.publish_on_behalf"in i.attributes)),n=e.find(i=>i.kind===l.ParticipantKind.AGENT&&i.attributes["lk.publish_on_behalf"]===(t==null?void 0:t.identity)),s=y([l.Track.Source.Microphone,l.Track.Source.Camera],t==null?void 0:t.identity),r=y([l.Track.Source.Microphone,l.Track.Source.Camera],n==null?void 0:n.identity),a=s.find(i=>i.source===l.Track.Source.Microphone)??r.find(i=>i.source===l.Track.Source.Microphone),u=s.find(i=>i.source===l.Track.Source.Camera)??r.find(i=>i.source===l.Track.Source.Camera),{segments:p}=B(a),m=d.useConnectionState(),{attributes:f}=G({participant:t}),b=c.useMemo(()=>m===l.ConnectionState.Disconnected?"disconnected":m===l.ConnectionState.Connecting||!t||!(f!=null&&f[_])?"connecting":f[_],[f,t,m]);return{agent:t,state:b,audioTrack:a,videoTrack:u,agentTranscriptions:p,agentAttributes:f}}function le(e){const t=o.useEnsureRoom(e),n=d.useConnectionState(t),s=c.useMemo(()=>o.recordingStatusObservable(t),[t,n]);return d.useObservableState(s,t.isRecording)}function W(e){const t=o.useRoomContext(),s=d.useConnectionState(t)===l.ConnectionState.Disconnected,r=c.useMemo(()=>o.setupTextStream(t,e),[t,e]),a=s?void 0:r;return{textStreams:d.useObservableState(a,[])}}function de(e){const{participantIdentities:t,trackSids:n}=e??{},{textStreams:s}=W(o.DataTopic.TRANSCRIPTION);return c.useMemo(()=>s.filter(a=>t?t.includes(a.participantInfo.identity):!0).filter(a=>{var u;return n?n.includes(((u=a.streamInfo.attributes)==null?void 0:u["lk.transcribed_track_id"])??""):!0}),[s,t,n])}const I=2,x=400,L=3,H=1e3;function pe(e){const t=T.useRef([]),n=T.useMemo(()=>new l.Mutex,[]),s=T.useCallback(async()=>n.lock().then(async b=>{for(;;){const i=t.current.pop();if(!i){b();break}switch(i.type){case"connect":await i.room.connect(...i.args).then(i.resolve).catch(i.reject);break;case"disconnect":await i.room.disconnect(...i.args).then(i.resolve).catch(i.reject);break}}}),[]),r=T.useRef([]),a=T.useCallback(b=>{let i=0;r.current=r.current.filter(S=>{const v=b.getTime()-S.getTime()<H;return v&&(i+=1),v}),i>L&&o.log.warn(`useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${L}x in ${H}ms). This is not recommended.`)},[]);T.useEffect(()=>{t.current=[];const b=new Date;r.current.push(b),a(b)},[e,a]);const u=T.useRef([]),p=T.useCallback(b=>{let i=0;u.current=u.current.filter(S=>{const v=b.getTime()-S.getTime()<x;return v&&(i+=1),v}),i>I&&o.log.warn(`useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${I}x in ${x}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`)},[]),m=T.useCallback(async(...b)=>new Promise((i,S)=>{if(!e)throw new Error("Called connect(), but room was unset");const v=new Date;p(v),t.current.push({type:"connect",room:e,args:b,resolve:i,reject:S}),u.current.push(v),s()}),[e,p,s]),f=T.useCallback(async(...b)=>new Promise((i,S)=>{if(!e)throw new Error("Called discconnect(), but room was unset");const v=new Date;p(v),t.current.push({type:"disconnect",room:e,args:b,resolve:i,reject:S}),u.current.push(v),s()}),[e,p,s]);return{connect:e?m:null,disconnect:e?f:null}}exports.useAudioPlayback=z;exports.useClearPinButton=K;exports.useDataChannel=Q;exports.useIsRecording=le;exports.useLiveKitRoom=Y;exports.useParticipantAttribute=ae;exports.useParticipantAttributes=G;exports.useParticipantInfo=X;exports.useParticipantPermissions=Z;exports.useParticipantTracks=y;exports.useParticipants=q;exports.useRemoteParticipant=ee;exports.useRemoteParticipants=E;exports.useRoomInfo=te;exports.useSequentialRoomConnectDisconnect=pe;exports.useSortedParticipants=ne;exports.useSpeakingParticipants=j;exports.useTextStream=W;exports.useToken=se;exports.useTrackByName=re;exports.useTrackTranscription=B;exports.useTranscriptions=de;exports.useVoiceAssistant=ue;
//# sourceMappingURL=shared-9gJpzp77.js.map
