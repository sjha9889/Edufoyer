{"version":3,"file":"hooks-4Z76Vz30.mjs","sources":["../src/hooks/internal/useResizeObserver.ts","../src/hooks/internal/useObservableState.ts","../src/hooks/internal/useMediaQuery.ts","../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useConnectionQualityIndicator.ts","../src/hooks/useConnectionStatus.ts","../src/hooks/useDataChannel.ts","../src/hooks/useDisconnectButton.ts","../src/hooks/useFacingMode.ts","../src/hooks/useFocusToggle.ts","../src/hooks/useGridLayout.ts","../src/hooks/useIsMuted.ts","../src/hooks/useIsSpeaking.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useLocalParticipantPermissions.ts","../src/hooks/useMediaDeviceSelect.ts","../src/hooks/useMediaDevices.ts","../src/hooks/useVisualStableUpdate.ts","../src/hooks/usePagination.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useParticipantTile.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/usePinnedTracks.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useStartAudio.ts","../src/hooks/useStartVideo.ts","../src/hooks/useSwipe.ts","../src/hooks/useChatToggle.ts","../src/hooks/useToken.ts","../src/hooks/useTrackMutedIndicator.ts","../src/hooks/useTrackToggle.ts","../src/hooks/useTracks.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useChat.ts","../src/hooks/usePersistentUserChoices.ts","../src/hooks/useIsEncrypted.ts","../src/hooks/useTrackVolume.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts","../src/hooks/useSequentialRoomConnectDisconnect.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\n\nconst useLatest = <T>(current: T) => {\n  const storedValue = React.useRef(current);\n  React.useEffect(() => {\n    storedValue.current = current;\n  });\n  return storedValue;\n};\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\n// @ts-ignore\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(\n  observable: Observable<T> | undefined,\n  startWith: T,\n  resetWhenObservableChanges = true,\n) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    if (resetWhenObservableChanges) {\n      setState(startWith);\n    }\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable, resetWhenObservableChanges]);\n  return state;\n}\n","import * as React from 'react';\n/**\n * Implementation used from https://github.com/juliencrn/usehooks-ts\n *\n * @internal\n */\nexport function useMediaQuery(query: string): boolean {\n  const getMatches = (query: string): boolean => {\n    // Prevents SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  };\n\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\n\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n\n  React.useEffect(() => {\n    const matchMedia = window.matchMedia(query);\n\n    // Triggered at the first client-side load and if query changes\n    handleChange();\n\n    // Listen matchMedia\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener('change', handleChange);\n    }\n\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener('change', handleChange);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [query]);\n\n  return matches;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\n * @example\n * ```tsx\n * const { quality } = useConnectionQualityIndicator();\n * // or\n * const { quality } = useConnectionQualityIndicator({ participant });\n * ```\n * @public\n */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, p.connectionQuality);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\n * custom implementation of it. It adds onClick handler to the button to disconnect\n * from the room.\n *\n * @example\n * ```tsx\n * const { buttonProps } = useDisconnectButton(buttonProps);\n * return <button {...buttonProps}>Disconnect</button>;\n * ```\n * @public\n */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  trackRef?: TrackReferenceOrPlaceholder;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\n *\n * @example\n * ```tsx\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\n * ```\n * @public\n */\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\n  }, [trackReference, layoutContext?.pin.state]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          if (inFocus) {\n            layoutContext?.pin.dispatch?.({\n              msg: 'clear_pin',\n            });\n          } else {\n            layoutContext?.pin.dispatch?.({\n              msg: 'set_pin',\n              trackReference,\n            });\n          }\n        },\n      }),\n    [props, className, trackReference, inFocus, layoutContext?.pin],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n *\n * @example\n * ```tsx\n * const { layout } = useGridLayout(gridElement, trackCount);\n * ```\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n  options: {\n    gridLayouts?: GridLayoutDefinition[];\n  } = {},\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\n  const { width, height } = useSize(gridElement);\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n    containerWidth: width,\n    containerHeight: height,\n  };\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  getTrackReferenceId,\n  mutedObserver,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\n * It returns a `boolean` that indicates if the track is muted or not.\n *\n * @example With a track reference\n * ```tsx\n * const isMuted = useIsMuted(track);\n * ```\n *\n * @example With a track source / participant\n * ```tsx\n * const isMuted = useIsMuted('camera', { participant });\n * ```\n *\n * @param sourceOrTrackRef - Either a `TrackReference` or a `Track.Source` (see usage examples)\n * @param options - Additional options when using a `Track.Source`\n * @returns boolean indicating if the track is muted\n *\n * @public\n */\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\nexport function useIsMuted(\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseIsMutedOptions = {},\n) {\n  const passedParticipant =\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\n  const p = useEnsureParticipant(passedParticipant);\n  const ref =\n    typeof sourceOrTrackRef === 'string'\n      ? { participant: p, source: sourceOrTrackRef }\n      : sourceOrTrackRef;\n  const [isMuted, setIsMuted] = React.useState(\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\n  );\n\n  React.useEffect(() => {\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [getTrackReferenceId(ref)]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\n * @example\n * ```tsx\n * const isSpeaking = useIsSpeaking(participant);\n * ```\n * @public\n */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useLocalParticipant` hook returns the local participant and the associated state\n * around the participant.\n *\n * @example\n * ```tsx\n * const { localParticipant } = useLocalParticipant();\n * ```\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(localParticipant.isCameraEnabled);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isScreenShareEnabled,\n  );\n\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [room]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\n *\n * @example\n * ```tsx\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\n * ```\n * @public\n */\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n  /**\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\n   * Most commonly this will emit a MediaDeviceError\n   */\n  onError?: (e: Error) => void;\n}\n\n/**\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\n * and a function to set the the active device.\n *\n * @example\n * ```tsx\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\n * ```\n * @public\n */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n  onError,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\n\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\n    [kind, requestPermissions, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\n    roomFallback?.getActiveDevice(kind) ?? 'default',\n  );\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, roomFallback),\n    [kind, roomFallback, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      if (!deviceId) {\n        return;\n      }\n      log.info('setCurrentDeviceId', deviceId);\n      setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/**\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\n *\n * @example\n * ```tsx\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\n * ```\n * @public\n */\nexport function useMediaDevices({\n  kind,\n  onError,\n}: {\n  kind: MediaDeviceKind;\n  onError?: (e: Error) => void;\n}) {\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError),\n    [kind, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  return devices;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\n * in an array. The algorithm only starts to update when there are more items than visually fit\n * on a page. If this is the case, it will make sure that speaking participants move to the first\n * page and are always visible.\n * @remarks\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\n * or start speaking.\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\n *\n * @example\n * ```tsx\n * const trackRefs = useTracks();\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\n * ```\n * @public\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\nimport { Track } from 'livekit-client';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  /** The track reference to display. */\n  trackRef?: TrackReferenceOrPlaceholder;\n  disableSpeakingIndicator?: boolean;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n}\n\n/**\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\n * @remarks\n * The returned props include many data attributes that are useful for CSS styling purposes because they\n * indicate the state of the participant and the track.\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\n * @public\n */\nexport function useParticipantTile<T extends HTMLElement>({\n  trackRef,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track =\n            trackReference.publication ??\n            trackReference.participant.getTrackPublication(trackReference.source);\n          onParticipantClick({ participant: trackReference.participant, track });\n        }\n      },\n    });\n  }, [\n    htmlProps,\n    onParticipantClick,\n    trackReference.publication,\n    trackReference.source,\n    trackReference.participant,\n  ]);\n\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\n  const micRef = React.useMemo(() => {\n    return {\n      participant: trackReference.participant,\n      source: Track.Source.Microphone,\n      publication: micTrack,\n    };\n  }, [micTrack, trackReference.participant]);\n  const isVideoMuted = useIsMuted(trackReference);\n  const isAudioMuted = useIsMuted(micRef);\n  const isSpeaking = useIsSpeaking(trackReference.participant);\n  const facingMode = useFacingMode(trackReference);\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': trackReference.participant.isLocal,\n      'data-lk-source': trackReference.source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/**\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\n * @remarks\n * To function properly, this hook must be called within a `LayoutContext`.\n * @example\n * ```tsx\n * const pinnedTracks = usePinnedTracks();\n * ```\n * @public\n */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import { setupStartVideo } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartVideoProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\n * that indicates whether video playback is allowed in the current context,\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\n *\n * @alpha\n */\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\n    () => setupStartVideo(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\n  );\n  const { canPlayVideo } = useObservableState(observable, {\n    canPlayVideo: roomEnsured.canPlaybackVideo,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartVideoPlayback(roomEnsured);\n        },\n        style: { display: canPlayVideo ? 'none' : 'block' },\n      }),\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayVideo };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\n * @remarks\n * Depends on the `LayoutContext` to work properly.\n * @see {@link ChatToggle}, {@link Chat}\n * @public\n */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  setupTrackMutedIndicator,\n  getTrackReferenceId,\n} from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { useObservableState } from './internal';\n\ninterface TrackMutedIndicatorReturnType {\n  isMuted: boolean;\n  className: string;\n}\n\n/**\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\n * and returns the muted state of the given track.\n *\n * @example\n * ```tsx\n * const { isMuted } = useTrackMutedIndicator(trackRef);\n * ```\n * @public\n */\nexport function useTrackMutedIndicator(\n  trackRef?: TrackReferenceOrPlaceholder,\n): TrackMutedIndicatorReturnType {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(trackReference),\n    [getTrackReferenceId(trackReference)],\n  );\n\n  const isMuted = useObservableState(\n    mediaMutedObserver,\n    !!(\n      trackReference.publication?.isMuted ||\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\n    ),\n  );\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {}\n\n/**\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\n * and functionality of the given track.\n *\n * @example\n * ```tsx\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\n * ```\n * @public\n */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  publishOptions,\n  onDeviceError,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const room = useMaybeRoomContext();\n  const track = room?.localParticipant?.getTrackPublication(source);\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\n  const userInteractionRef = React.useRef(false);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () =>\n      room\n        ? setupMediaToggle<T>(source, room, captureOptions, publishOptions, onDeviceError)\n        : setupManualToggle(),\n    [room, source, JSON.stringify(captureOptions), publishOptions],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled, userInteractionRef.current);\n    userInteractionRef.current = false;\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      userInteractionRef.current = true;\n      toggle().catch(() => (userInteractionRef.current = false));\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n    ? TrackReferenceOrPlaceholder[]\n    : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [\n    room,\n    JSON.stringify(options.onlySubscribed),\n    JSON.stringify(options.updateOnlyOn),\n    JSON.stringify(sources),\n  ]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTrackPublications()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\nimport { setupChat } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal/useObservableState';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useChat` hook provides chat functionality for a LiveKit room.\n *\n * @remarks\n * Message history is not persisted and will be lost if the component is refreshed.\n * You may want to persist message history in the browser, a cache or a database.\n *\n * @returns An object containing:\n * - `chatMessages` - Array of received chat messages\n * - `send` - Function to send a new message\n * - `isSending` - Boolean indicating if a message is currently being sent\n *\n * @example\n * ```tsx\n * function ChatComponent() {\n *   const { chatMessages, send, isSending } = useChat();\n *\n *   return (\n *     <div>\n *       {chatMessages.map((msg) => (\n *         <div key={msg.timestamp}>\n *           {msg.from?.identity}: {msg.message}\n *         </div>\n *       ))}\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\n *         Send Message\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n * @public\n */\nexport function useChat(options?: ChatOptions) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n  const isDisconnected = React.useMemo(\n    () => connectionState === ConnectionState.Disconnected,\n    [connectionState],\n  ); // used to reset the messages on room disconnect\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\n    () => setupChat(room, options),\n    [room, options, isDisconnected],\n  );\n  const isSending = useObservableState(setup.isSendingObservable, false);\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\n\n  return { send: setup.send, chatMessages, isSending };\n}\n","import type { LocalUserChoices } from '@livekit/components-core';\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * Options for the `usePersistentDeviceSettings` hook.\n * @alpha\n */\nexport interface UsePersistentUserChoicesOptions {\n  /**\n   * The default value to use if reading from local storage returns no results or fails.\n   */\n  defaults?: Partial<LocalUserChoices>;\n  /**\n   * Whether to prevent saving to persistent storage.\n   * @defaultValue false\n   */\n  preventSave?: boolean;\n  /**\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\n   * @defaultValue false\n   */\n  preventLoad?: boolean;\n}\n\n/**\n * A hook that provides access to user choices stored in local storage, such as\n * selected media devices and their current state (on or off), as well as the user name.\n * @alpha\n */\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\n  );\n\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\n  }, []);\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\n  }, []);\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\n  }, []);\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\n  }, []);\n  const saveUsername = React.useCallback((username: string) => {\n    setSettings((prev) => ({ ...prev, username: username }));\n  }, []);\n\n  React.useEffect(() => {\n    saveUserChoices(userChoices, options.preventSave ?? false);\n  }, [userChoices, options.preventSave]);\n\n  return {\n    userChoices,\n    saveAudioInputEnabled,\n    saveVideoInputEnabled,\n    saveAudioInputDeviceId,\n    saveVideoInputDeviceId,\n    saveUsername,\n  };\n}\n","import * as React from 'react';\nimport { LocalParticipant } from 'livekit-client';\nimport type { Participant, Room } from 'livekit-client';\nimport { encryptionStatusObservable } from '@livekit/components-core';\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * @alpha\n */\nexport interface UseIsEncryptedOptions {\n  room?: Room;\n}\n\n/**\n * @alpha\n */\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\n  const p = useEnsureParticipant(participant);\n\n  const room = useEnsureRoom(options.room);\n\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\n  const isEncrypted = useObservableState(\n    observer,\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\n  );\n  return isEncrypted;\n}\n","import * as React from 'react';\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\nimport { Track, createAudioAnalyser } from 'livekit-client';\nimport {\n  type TrackReference,\n  isTrackReference,\n  type TrackReferenceOrPlaceholder,\n} from '@livekit/components-core';\n\n/**\n * @alpha\n * Hook for tracking the volume of an audio track using the Web Audio API.\n */\nexport function useTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\n) {\n  const track = isTrackReference(trackOrTrackReference)\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\n    : trackOrTrackReference;\n  const [volume, setVolume] = React.useState(0);\n  React.useEffect(() => {\n    if (!track || !track.mediaStream) {\n      return;\n    }\n\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) {\n        const a = dataArray[i];\n        sum += a * a;\n      }\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\n    };\n\n    const interval = setInterval(updateVolume, 1000 / 30);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return volume;\n}\n\nconst normalizeFrequencies = (frequencies: Float32Array) => {\n  const normalizeDb = (value: number) => {\n    const minDb = -100;\n    const maxDb = -10;\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\n    db = Math.sqrt(db);\n\n    return db;\n  };\n\n  // Normalize all frequency values\n  return frequencies.map((value) => {\n    if (value === -Infinity) {\n      return 0;\n    }\n    return normalizeDb(value);\n  });\n};\n\n/**\n * Interface for configuring options for the useMultibandTrackVolume hook.\n * @alpha\n */\nexport interface MultiBandTrackVolumeOptions {\n  bands?: number;\n  /**\n   * cut off of frequency bins on the lower end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  loPass?: number;\n  /**\n   * cut off of frequency bins on the higher end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  hiPass?: number;\n  /**\n   * update should run every x ms\n   */\n  updateInterval?: number;\n  analyserOptions?: AnalyserOptions;\n}\n\nconst multibandDefaults = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 },\n} as const satisfies MultiBandTrackVolumeOptions;\n\n/**\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\n * @alpha\n */\nexport function useMultibandTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: MultiBandTrackVolumeOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...multibandDefaults, ...options };\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\n    new Array(opts.bands).fill(0),\n  );\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Float32Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getFloatFrequencyData(dataArray);\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\n      for (let i = 0; i < dataArray.length; i++) {\n        frequencies[i] = dataArray[i];\n      }\n      frequencies = frequencies.slice(options.loPass, options.hiPass);\n\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\n      const chunkSize = Math.ceil(normalizedFrequencies.length / opts.bands); // we want logarithmic chunking here\n      const chunks: Array<number> = [];\n      for (let i = 0; i < opts.bands; i++) {\n        const summedVolumes = normalizedFrequencies\n          .slice(i * chunkSize, (i + 1) * chunkSize)\n          .reduce((acc, val) => (acc += val), 0);\n        chunks.push(summedVolumes / chunkSize);\n      }\n\n      setFrequencyBands(chunks);\n    };\n\n    const interval = setInterval(updateVolume, opts.updateInterval);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return frequencyBands;\n}\n\n/**\n * @alpha\n */\nexport interface AudioWaveformOptions {\n  barCount?: number;\n  volMultiplier?: number;\n  updateInterval?: number;\n}\n\nconst waveformDefaults = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20,\n} as const satisfies AudioWaveformOptions;\n\n/**\n * @alpha\n */\nexport function useAudioWaveform(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: AudioWaveformOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...waveformDefaults, ...options };\n\n  const aggregateWave = React.useRef(new Float32Array());\n  const timeRef = React.useRef(performance.now());\n  const updates = React.useRef(0);\n  const [bars, setBars] = React.useState<number[]>([]);\n\n  const onUpdate = React.useCallback((wave: Float32Array) => {\n    setBars(\n      Array.from(\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ),\n    );\n  }, []);\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, {\n      fftSize: getFFTSizeValue(opts.barCount),\n    });\n\n    const bufferLength = getFFTSizeValue(opts.barCount);\n    const dataArray = new Float32Array(bufferLength);\n\n    const update = () => {\n      updateWaveform = requestAnimationFrame(update);\n      analyser.getFloatTimeDomainData(dataArray);\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\n      updates.current += 1;\n\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\n        const newData = dataArray.map((v) => v / updates.current);\n        onUpdate(newData);\n        timeRef.current = performance.now();\n        updates.current = 0;\n      }\n    };\n\n    let updateWaveform = requestAnimationFrame(update);\n\n    return () => {\n      cleanup();\n      cancelAnimationFrame(updateWaveform);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\n\n  return {\n    bars,\n  };\n}\n\nfunction getFFTSizeValue(x: number) {\n  if (x < 32) return 32;\n  else return pow2ceil(x);\n}\n\n// function sigmoid(x: number, k = 2, s = 0) {\n//   return 1 / (1 + Math.exp(-(x - s) / k));\n// }\n\nfunction pow2ceil(v: number) {\n  let p = 2;\n  while ((v >>= 1)) {\n    p <<= 1;\n  }\n  return p;\n}\n\nfunction filterData(audioData: Float32Array, numSamples: number) {\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\n  const filteredData = new Float32Array(numSamples);\n  for (let i = 0; i < numSamples; i++) {\n    const blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\n  }\n  return filteredData;\n}\n\n// function normalizeData(audioData: Float32Array) {\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\n//   return audioData.map((n) => n * multiplier);\n// }\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Track } from 'livekit-client';\nimport { useMaybeParticipantContext } from '../context';\nimport { useParticipants } from './useParticipants';\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks(\n  sources: Track.Source[],\n  participantIdentity?: string,\n): TrackReference[] {\n  const participantContext = useMaybeParticipantContext();\n  const participants = useParticipants({ updateOnlyOn: [] });\n\n  const p = React.useMemo(() => {\n    if (participantIdentity) {\n      return participants.find((p) => p.identity === participantIdentity);\n    }\n    return participantContext;\n  }, [participantIdentity, participants, participantContext]);\n\n  const observable = React.useMemo(() => {\n    if (!p) {\n      return undefined;\n    }\n    return participantTracksObservable(p, { sources });\n  }, [p, JSON.stringify(sources)]);\n\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n * @deprecated this is an internal hook that's only used by deprecated APIs\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\n\n/**\n * @beta\n */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'initializing'\n  | 'listening'\n  | 'thinking'\n  | 'speaking';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = 'lk.agent.state';\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) => p.kind === ParticipantKind.AGENT && !('lk.publish_on_behalf' in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT && p.attributes['lk.publish_on_behalf'] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useRoomContext } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string) {\n  const room = useRoomContext();\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic } from '@livekit/components-core';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION);\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(stream.streamInfo.attributes?.['lk.transcribed_track_id'] ?? '')\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n","import { Mutex, type Room } from 'livekit-client';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { log } from '@livekit/components-core';\n\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY = 2;\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_MS = 400;\n\nconst ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY = 3;\nconst ROOM_CHANGE_WARNING_THRESHOLD_MS = 1000;\n\n/** @public */\nexport type UseSequentialRoomConnectDisconnectResults<R extends Room | undefined> = {\n  connect: typeof Room.prototype.connect & (R extends undefined ? null : unknown);\n  disconnect: typeof Room.prototype.disconnect & (R extends undefined ? null : unknown);\n};\n\n/**\n * When calling room.disconnect() as part of a React useEffect cleanup function, it is possible for\n * a room.connect(...) in the effect body to start running while the room.disconnect() is still\n * running. This hook sequentializes these two operations, so they always happen in order and\n * never overlap.\n *\n * @example\n * ```ts\n * const { connect, disconnect } = useSequentialRoomConnectDisconnect(room);\n *\n * // Connecting to a room:\n * useEffect(() => {\n *   connect();\n *   return () => disconnect();\n * }, [connect, disconnect]);\n * ```\n *\n * @public\n */\nexport function useSequentialRoomConnectDisconnect<R extends Room | undefined>(\n  room: R,\n): UseSequentialRoomConnectDisconnectResults<R> {\n  const connectDisconnectQueueRef = useRef<\n    Array<\n      | {\n          type: 'connect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.connect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.connect>>) => void;\n          reject: (err: Error) => void;\n        }\n      | {\n          type: 'disconnect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.disconnect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.disconnect>>) => void;\n          reject: (err: Error) => void;\n        }\n    >\n  >([]);\n\n  // Process room connection / disconnection events and execute them in series\n  // The main queue is a ref, so one invocation of this function can continue to process newly added\n  // events\n  const processConnectsAndDisconnectsLock = useMemo(() => new Mutex(), []);\n  const processConnectsAndDisconnects = useCallback(async () => {\n    return processConnectsAndDisconnectsLock.lock().then(async (unlock) => {\n      while (true) {\n        const message = connectDisconnectQueueRef.current.pop();\n        if (!message) {\n          unlock();\n          break;\n        }\n\n        switch (message.type) {\n          case 'connect':\n            await message.room\n              .connect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n          case 'disconnect':\n            await message.room\n              .disconnect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n        }\n      }\n    });\n  }, []);\n\n  const roomChangedTimesRef = useRef<Array<Date>>([]);\n  const checkRoomThreshold = useCallback((now: Date) => {\n    let roomChangesInThreshold = 0;\n    roomChangedTimesRef.current = roomChangedTimesRef.current.filter((i) => {\n      const isWithinThreshold = now.getTime() - i.getTime() < ROOM_CHANGE_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        roomChangesInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (roomChangesInThreshold > ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY}x in ${ROOM_CHANGE_WARNING_THRESHOLD_MS}ms). This is not recommended.`,\n      );\n    }\n  }, []);\n\n  // When the room changes, clear any pending connect / disconnect calls and log when it happened\n  useEffect(() => {\n    connectDisconnectQueueRef.current = [];\n\n    const now = new Date();\n    roomChangedTimesRef.current.push(now);\n    checkRoomThreshold(now);\n  }, [room, checkRoomThreshold]);\n\n  const connectDisconnectEnqueueTimes = useRef<Array<Date>>([]);\n  const checkConnectDisconnectThreshold = useCallback((now: Date) => {\n    let connectDisconnectsInThreshold = 0;\n    connectDisconnectEnqueueTimes.current = connectDisconnectEnqueueTimes.current.filter((i) => {\n      const isWithinThreshold =\n        now.getTime() - i.getTime() < CONNECT_DISCONNECT_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        connectDisconnectsInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (connectDisconnectsInThreshold > CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY}x in ${CONNECT_DISCONNECT_WARNING_THRESHOLD_MS}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`,\n      );\n    }\n  }, []);\n\n  const connect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.connect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called connect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'connect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  const disconnect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.disconnect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called discconnect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'disconnect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  return {\n    connect: room ? connect : null,\n    disconnect: room ? disconnect : null,\n  } as UseSequentialRoomConnectDisconnectResults<R>;\n}\n"],"names":["useLatest","current","storedValue","React","useResizeObserver","target","callback","resizeObserver","getResizeObserver","storedCallback","didUnsubscribe","targetEl","cb","entry","observer","createResizeObserver","ticking","allEntries","callbacks","entries","obs","triggered","cbs","cbIndex","_resizeObserver","useSize","size","setSize","width","height","resizeCallback","useObservableState","observable","startWith","resetWhenObservableChanges","state","setState","subscription","useMediaQuery","query","getMatches","matches","setMatches","handleChange","matchMedia","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","roomAudioPlaybackAllowedObservable","canPlayAudio","useClearPinButton","props","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useConnectionQualityIndicator","options","p","useEnsureParticipant","connectionQualityObserver","setupConnectionQualityIndicator","quality","useConnectionState","r","connectionStateObserver","useDataChannel","topicOrCallback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","useDisconnectButton","connectionState","disconnect","setupDisconnectButton","ConnectionState","useFacingMode","trackReference","LocalTrackPublication","localTrack","facingMode","facingModeFromLocalTrack","useFocusToggle","trackRef","useEnsureTrackRef","layoutContext","useMaybeLayoutContext","setupFocusToggle","inFocus","isTrackReferencePinned","event","_a","_c","_b","_e","_d","useGridLayout","gridElement","trackCount","gridLayouts","GRID_LAYOUTS","layout","selectGridLayout","useIsMuted","sourceOrTrackRef","passedParticipant","ref","isMuted","setIsMuted","listener","mutedObserver","getTrackReferenceId","useIsSpeaking","participant","createIsSpeakingObserver","useLocalParticipant","localParticipant","setLocalParticipant","isMicrophoneEnabled","setIsMicrophoneEnabled","isCameraEnabled","setIsCameraEnabled","isScreenShareEnabled","setIsScreenShareEnabled","lastMicrophoneError","setLastMicrophoneError","lastCameraError","setLastCameraError","microphoneTrack","setMicrophoneTrack","cameraTrack","setCameraTrack","handleUpdate","media","observeParticipantMedia","useLocalParticipantPermissions","permissionObserver","participantPermissionObserver","useMediaDeviceSelect","kind","track","requestPermissions","onError","roomContext","useMaybeRoomContext","roomFallback","Room","deviceObserver","createMediaDeviceObserver","devices","currentDeviceId","setCurrentDeviceId","activeDeviceObservable","setActiveMediaDevice","setupDeviceSelector","deviceId","log","useMediaDevices","useVisualStableUpdate","trackReferences","maxItemsOnPage","lastTrackRefs","lastMaxItemsOnPage","layoutChanged","sortedTrackRefs","sortTrackReferences","updatedTrackRefs","updatePages","error","usePagination","itemPerPage","currentPage","setCurrentPage","totalPageCount","lastItemIndex","firstItemIndex","changePage","direction","goToPage","num","tracksOnPage","useParticipantInfo","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useParticipantTile","onParticipantClick","disableSpeakingIndicator","htmlProps","mergedProps","setupParticipantTile","micTrack","Track","micRef","isVideoMuted","isAudioMuted","isSpeaking","useRemoteParticipants","participants","setParticipants","connectedParticipantsObserver","useParticipants","remoteParticipants","usePinnedTracks","useEnsureLayoutContext","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useStartAudio","handleStartAudioPlayback","setupStartAudio","useStartVideo","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","setupStartVideo","canPlayVideo","useSwipe","element","touchStart","touchEnd","minSwipeDistance","onTouchStart","onTouchMove","onTouchEnd","distance","isLeftSwipe","isRightSwipe","elementCopy","useChatToggle","setupChatToggle","useToken","tokenEndpoint","roomName","token","setToken","params","res","accessToken","useTrackMutedIndicator","mediaMutedObserver","setupTrackMutedIndicator","useTrackToggle","source","onChange","initialState","captureOptions","publishOptions","onDeviceError","rest","userInteractionRef","toggle","pendingObserver","enabledObserver","setupMediaToggle","setupManualToggle","pending","enabled","newProps","clickHandler","evt","useTracks","sources","setTrackReferences","sources_","s","isSourceWitOptions","trackReferencesObservable","isSourcesWithOptions","requirePlaceholder","requiredPlaceholders","trackReferencesWithPlaceholders","placeholderSource","publication","placeholder","difference","setA","setB","_difference","elem","placeholderMap","sourcesThatNeedPlaceholder","sourceWithOption","sourcesOfSubscribedTracks","pub","trackSource","placeholderNeededForThisParticipant","useTrackRefBySourceOrName","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","useTrackByName","useChat","isDisconnected","setup","setupChat","chatMessages","usePersistentUserChoices","userChoices","setSettings","loadUserChoices","saveAudioInputEnabled","isEnabled","prev","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","username","saveUserChoices","useIsEncrypted","encryptionStatusObservable","useTrackVolume","trackOrTrackReference","isTrackReference","volume","setVolume","cleanup","analyser","createAudioAnalyser","bufferLength","dataArray","interval","sum","i","a","normalizeFrequencies","frequencies","normalizeDb","value","db","multibandDefaults","useMultibandTrackVolume","opts","frequencyBands","setFrequencyBands","normalizedFrequencies","chunkSize","chunks","summedVolumes","acc","val","waveformDefaults","useAudioWaveform","aggregateWave","timeRef","updates","bars","setBars","onUpdate","wave","filterData","v","getFFTSizeValue","update","updateWaveform","newData","x","pow2ceil","audioData","numSamples","blockSize","filteredData","blockStart","j","useParticipantTracks","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","trackSyncTimeObserver","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","addTimestampsToTranscription","trackTranscriptionObserver","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","state_attribute","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","attributes","useIsRecording","recordingStatusObservable","useTextStream","textStreamData","setupTextStream","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream","CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY","CONNECT_DISCONNECT_WARNING_THRESHOLD_MS","ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY","ROOM_CHANGE_WARNING_THRESHOLD_MS","useSequentialRoomConnectDisconnect","connectDisconnectQueueRef","useRef","processConnectsAndDisconnectsLock","useMemo","Mutex","processConnectsAndDisconnects","useCallback","unlock","roomChangedTimesRef","checkRoomThreshold","now","roomChangesInThreshold","isWithinThreshold","useEffect","connectDisconnectEnqueueTimes","checkConnectDisconnectThreshold","connectDisconnectsInThreshold","connect","args","resolve","reject"],"mappings":"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"}